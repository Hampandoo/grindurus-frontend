import {
  AdapterBlueprint,
  WalletConnectConnector,
  WcConstantsUtil,
  WcHelpersUtil
} from "./chunk-JQJORWEF.js";
import "./chunk-YARLWCGU.js";
import "./chunk-C6X7UTBU.js";
import {
  ConstantsUtil as ConstantsUtil2,
  PresetsUtil,
  ProviderUtil
} from "./chunk-3SG5IFPP.js";
import "./chunk-FFZJUOLV.js";
import {
  ConstantsUtil,
  CoreHelperUtil,
  OptionsController,
  ParseUtil,
  StorageUtil,
  isReownName
} from "./chunk-EWULVIQE.js";
import "./chunk-6YBRIP4U.js";
import "./chunk-PZP6M6XD.js";
import {
  BrowserProvider,
  Contract,
  InfuraProvider,
  JsonRpcProvider,
  JsonRpcSigner,
  formatEther,
  formatUnits,
  hexlify,
  isHexString,
  parseUnits,
  toUtf8Bytes
} from "./chunk-UUZSNFSV.js";
import "./chunk-U3D3H35W.js";
import "./chunk-NZ6LB726.js";
import "./chunk-GWZUYL5Y.js";
import "./chunk-KTPVD53X.js";
import "./chunk-DJAHXZKE.js";
import "./chunk-4FZNB7RA.js";
import "./chunk-JAIDI6O3.js";
import "./chunk-UDY33WFK.js";
import "./chunk-L3IKO2KK.js";

// ../../node_modules/@reown/appkit-utils/dist/esm/src/ethers/EthersHelpersUtil.js
var EthersHelpersUtil = {
  hexStringToNumber(value) {
    const string = value.startsWith("0x") ? value.slice(2) : value;
    const number = parseInt(string, 16);
    return number;
  },
  numberToHexString(value) {
    return `0x${value.toString(16)}`;
  },
  async getUserInfo(provider) {
    const [addresses, chainId] = await Promise.all([
      EthersHelpersUtil.getAddresses(provider),
      EthersHelpersUtil.getChainId(provider)
    ]);
    return { chainId, addresses };
  },
  async getChainId(provider) {
    const chainId = await provider.request({ method: "eth_chainId" });
    return Number(chainId);
  },
  async getAddress(provider) {
    const [address] = await provider.request({ method: "eth_accounts" });
    return address;
  },
  async getAddresses(provider) {
    const addresses = await provider.request({ method: "eth_accounts" });
    return addresses;
  },
  async addEthereumChain(provider, caipNetwork) {
    var _a, _b;
    const rpcUrls = ((_a = caipNetwork.rpcUrls["chainDefault"]) == null ? void 0 : _a.http) || [];
    await provider.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: EthersHelpersUtil.numberToHexString(caipNetwork.id),
          rpcUrls: [...rpcUrls],
          chainName: caipNetwork.name,
          nativeCurrency: {
            name: caipNetwork.nativeCurrency.name,
            decimals: caipNetwork.nativeCurrency.decimals,
            symbol: caipNetwork.nativeCurrency.symbol
          },
          blockExplorerUrls: [(_b = caipNetwork.blockExplorers) == null ? void 0 : _b.default.url],
          iconUrls: [PresetsUtil.NetworkImageIds[caipNetwork.id]]
        }
      ]
    });
  }
};

// ../../node_modules/@reown/appkit-adapter-ethers/dist/esm/src/utils/EthersMethods.js
var EthersMethods = {
  signMessage: async (message, provider, address) => {
    if (!provider) {
      throw new Error("signMessage - provider is undefined");
    }
    const hexMessage = isHexString(message) ? message : hexlify(toUtf8Bytes(message));
    const signature = await provider.request({
      method: "personal_sign",
      params: [hexMessage, address]
    });
    return signature;
  },
  estimateGas: async (data, provider, address, networkId) => {
    if (!provider) {
      throw new Error("estimateGas - provider is undefined");
    }
    if (!address) {
      throw new Error("estimateGas - address is undefined");
    }
    if (data.chainNamespace && data.chainNamespace !== "eip155") {
      throw new Error("estimateGas - chainNamespace is not eip155");
    }
    const txParams = {
      from: data.address,
      to: data.to,
      data: data.data,
      type: 0
    };
    const browserProvider = new BrowserProvider(provider, networkId);
    const signer = new JsonRpcSigner(browserProvider, address);
    return await signer.estimateGas(txParams);
  },
  sendTransaction: async (data, provider, address, networkId) => {
    if (!provider) {
      throw new Error("sendTransaction - provider is undefined");
    }
    if (!address) {
      throw new Error("sendTransaction - address is undefined");
    }
    if (data.chainNamespace && data.chainNamespace !== "eip155") {
      throw new Error("sendTransaction - chainNamespace is not eip155");
    }
    const txParams = {
      to: data.to,
      value: data.value,
      gasLimit: data.gas,
      gasPrice: data.gasPrice,
      data: data.data,
      type: 0
    };
    const browserProvider = new BrowserProvider(provider, networkId);
    const signer = new JsonRpcSigner(browserProvider, address);
    const txResponse = await signer.sendTransaction(txParams);
    const txReceipt = await txResponse.wait();
    return (txReceipt == null ? void 0 : txReceipt.hash) || null;
  },
  writeContract: async (data, provider, address, chainId) => {
    if (!provider) {
      throw new Error("writeContract - provider is undefined");
    }
    if (!address) {
      throw new Error("writeContract - address is undefined");
    }
    const browserProvider = new BrowserProvider(provider, chainId);
    const signer = new JsonRpcSigner(browserProvider, address);
    const contract = new Contract(data.tokenAddress, data.abi, signer);
    if (!contract || !data.method) {
      throw new Error("Contract method is undefined");
    }
    const method = contract[data.method];
    if (method) {
      return await method(...data.args);
    }
    throw new Error("Contract method is undefined");
  },
  getEnsAddress: async (value, caipNetwork) => {
    try {
      const chainId = Number(caipNetwork.id);
      let ensName = null;
      let wcName = false;
      if (isReownName(value)) {
        wcName = await WcHelpersUtil.resolveReownName(value) || false;
      }
      if (chainId === 1) {
        const ensProvider = new InfuraProvider("mainnet");
        ensName = await ensProvider.resolveName(value);
      }
      return ensName || wcName || false;
    } catch {
      return false;
    }
  },
  getEnsAvatar: async (value, chainId) => {
    if (chainId === 1) {
      const ensProvider = new InfuraProvider("mainnet");
      const avatar = await ensProvider.getAvatar(value);
      return avatar || false;
    }
    return false;
  },
  parseWalletCapabilities: (str) => {
    try {
      return JSON.parse(str);
    } catch (error) {
      throw new Error("Error parsing wallet capabilities");
    }
  },
  parseUnits,
  formatUnits
};

// ../../node_modules/@reown/appkit-adapter-ethers/dist/esm/src/client.js
var EthersAdapter = class extends AdapterBlueprint {
  constructor() {
    super({});
    this.adapterType = "ethers";
    this.balancePromises = {};
    this.providerHandlers = null;
    this.namespace = ConstantsUtil.CHAIN.EVM;
  }
  async createEthersConfig(options) {
    if (!options.metadata) {
      return void 0;
    }
    let injectedProvider = void 0;
    function getInjectedProvider() {
      if (injectedProvider) {
        return injectedProvider;
      }
      if (typeof window === "undefined") {
        return void 0;
      }
      if (!window.ethereum) {
        return void 0;
      }
      injectedProvider = window.ethereum;
      return injectedProvider;
    }
    async function getCoinbaseProvider() {
      var _a, _b, _c;
      try {
        const { createCoinbaseWalletSDK } = await import("./dist-Y2G22IR6.js");
        if (typeof window === "undefined") {
          return void 0;
        }
        const coinbaseSdk = createCoinbaseWalletSDK({
          appName: (_a = options == null ? void 0 : options.metadata) == null ? void 0 : _a.name,
          appLogoUrl: (_b = options == null ? void 0 : options.metadata) == null ? void 0 : _b.icons[0],
          appChainIds: ((_c = options.networks) == null ? void 0 : _c.map((caipNetwork) => caipNetwork.id)) || [1, 84532],
          preference: {
            options: options.coinbasePreference ?? "all"
          }
        });
        return coinbaseSdk.getProvider();
      } catch (error) {
        console.error("Failed to import Coinbase Wallet SDK:", error);
        return void 0;
      }
    }
    const providers = { metadata: options.metadata };
    if (options.enableInjected !== false) {
      providers.injected = getInjectedProvider();
    }
    if (options.enableCoinbase !== false) {
      const coinbaseProvider = await getCoinbaseProvider();
      if (coinbaseProvider) {
        providers.coinbase = coinbaseProvider;
      }
    }
    providers.EIP6963 = options.enableEIP6963 !== false;
    return providers;
  }
  async signMessage(params) {
    const { message, address, provider } = params;
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    try {
      const signature = await EthersMethods.signMessage(message, provider, address);
      return { signature };
    } catch (error) {
      throw new Error("EthersAdapter:signMessage - Sign message failed");
    }
  }
  async sendTransaction(params) {
    var _a;
    if (!params.provider) {
      throw new Error("Provider is undefined");
    }
    const tx = await EthersMethods.sendTransaction({
      value: params.value,
      to: params.to,
      data: params.data,
      gas: params.gas,
      gasPrice: params.gasPrice,
      address: params.address
    }, params.provider, params.address, Number((_a = params.caipNetwork) == null ? void 0 : _a.id));
    return { hash: tx };
  }
  async writeContract(params) {
    var _a;
    if (!params.provider) {
      throw new Error("Provider is undefined");
    }
    const { address } = ParseUtil.parseCaipAddress(params.caipAddress);
    const result = await EthersMethods.writeContract(params, params.provider, address, Number((_a = params.caipNetwork) == null ? void 0 : _a.id));
    return { hash: result };
  }
  async estimateGas(params) {
    const { provider, caipNetwork, address } = params;
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    try {
      const result = await EthersMethods.estimateGas({
        data: params.data,
        to: params.to,
        address
      }, provider, address, Number(caipNetwork == null ? void 0 : caipNetwork.id));
      return { gas: result };
    } catch (error) {
      throw new Error("EthersAdapter:estimateGas - Estimate gas failed");
    }
  }
  async getEnsAddress(params) {
    const { name, caipNetwork } = params;
    if (caipNetwork) {
      const result = await EthersMethods.getEnsAddress(name, caipNetwork);
      return { address: result };
    }
    return { address: "" };
  }
  parseUnits(params) {
    return EthersMethods.parseUnits(params.value, params.decimals);
  }
  formatUnits(params) {
    return EthersMethods.formatUnits(params.value, params.decimals);
  }
  async syncConnection(params) {
    const { id, chainId } = params;
    const connector = this.connectors.find((c) => c.id === id);
    const selectedProvider = connector == null ? void 0 : connector.provider;
    if (!selectedProvider) {
      throw new Error("Provider not found");
    }
    const accounts = await selectedProvider.request({
      method: "eth_requestAccounts"
    });
    const requestChainId = await selectedProvider.request({
      method: "eth_chainId"
    });
    this.listenProviderEvents(selectedProvider);
    if (!accounts[0]) {
      throw new Error("No accounts found");
    }
    if (!(connector == null ? void 0 : connector.type)) {
      throw new Error("Connector type not found");
    }
    return {
      address: accounts[0],
      chainId: Number(requestChainId) || Number(chainId),
      provider: selectedProvider,
      type: connector.type,
      id
    };
  }
  async syncConnectors(options) {
    var _a;
    this.ethersConfig = await this.createEthersConfig(options);
    if ((_a = this.ethersConfig) == null ? void 0 : _a.EIP6963) {
      this.listenInjectedConnector(true);
    }
    const connectors = Object.keys(this.ethersConfig || {}).filter((key) => key !== "metadata" && key !== "EIP6963");
    connectors.forEach((connector) => {
      var _a2, _b;
      const key = connector === "coinbase" ? "coinbaseWalletSDK" : connector;
      const isInjectedConnector = connector === ConstantsUtil.CONNECTOR_ID.INJECTED;
      if (this.namespace) {
        this.addConnector({
          id: key,
          explorerId: PresetsUtil.ConnectorExplorerIds[key],
          imageUrl: (_a2 = options == null ? void 0 : options.connectorImages) == null ? void 0 : _a2[key],
          name: PresetsUtil.ConnectorNamesMap[key] || "Unknown",
          imageId: PresetsUtil.ConnectorImageIds[key],
          type: PresetsUtil.ConnectorTypesMap[key] ?? "EXTERNAL",
          info: isInjectedConnector ? void 0 : { rdns: key },
          chain: this.namespace,
          chains: [],
          provider: (_b = this.ethersConfig) == null ? void 0 : _b[connector]
        });
      }
    });
  }
  setUniversalProvider(universalProvider) {
    this.addConnector(new WalletConnectConnector({
      provider: universalProvider,
      caipNetworks: this.caipNetworks || [],
      namespace: "eip155"
    }));
  }
  eip6963EventHandler(event) {
    var _a;
    if (event.detail) {
      const { info, provider } = event.detail;
      const existingConnector = (_a = this.connectors) == null ? void 0 : _a.find((c) => c.name === (info == null ? void 0 : info.name));
      if (!existingConnector) {
        const type = PresetsUtil.ConnectorTypesMap[ConstantsUtil.CONNECTOR_ID.EIP6963];
        const id = (info == null ? void 0 : info.rdns) || (info == null ? void 0 : info.name) || (info == null ? void 0 : info.uuid);
        if (type && this.namespace && id) {
          this.addConnector({
            id,
            type,
            imageUrl: info == null ? void 0 : info.icon,
            name: (info == null ? void 0 : info.name) || "Unknown",
            provider,
            info,
            chain: this.namespace,
            chains: []
          });
        }
      }
    }
  }
  listenInjectedConnector(enableEIP6963) {
    if (typeof window !== "undefined" && enableEIP6963) {
      const handler = this.eip6963EventHandler.bind(this);
      window.addEventListener(ConstantsUtil2.EIP6963_ANNOUNCE_EVENT, handler);
      window.dispatchEvent(new Event(ConstantsUtil2.EIP6963_REQUEST_EVENT));
    }
  }
  async connect({ id, type, chainId }) {
    var _a;
    const connector = this.connectors.find((c) => c.id === id);
    const selectedProvider = connector == null ? void 0 : connector.provider;
    if (!selectedProvider) {
      throw new Error("Provider not found");
    }
    let accounts = [];
    let requestChainId = void 0;
    if (type === "AUTH") {
      const { address } = await selectedProvider.connect({
        chainId,
        preferredAccountType: OptionsController.state.defaultAccountTypes.eip155
      });
      accounts = [address];
    } else {
      accounts = await selectedProvider.request({
        method: "eth_requestAccounts"
      });
      requestChainId = await selectedProvider.request({
        method: "eth_chainId"
      });
      if (requestChainId !== chainId) {
        const caipNetwork = (_a = this.caipNetworks) == null ? void 0 : _a.find((n) => n.id === chainId);
        if (!caipNetwork) {
          throw new Error("EthersAdapter:connect - could not find the caipNetwork to switch");
        }
        try {
          await this.switchNetwork({
            caipNetwork,
            provider: selectedProvider,
            providerType: type
          });
        } catch (error) {
          throw new Error("EthersAdapter:connect - Switch network failed");
        }
      }
      this.listenProviderEvents(selectedProvider);
    }
    return {
      address: accounts[0],
      chainId: Number(chainId),
      provider: selectedProvider,
      type,
      id
    };
  }
  async reconnect(params) {
    const { id, chainId } = params;
    const connector = this.connectors.find((c) => c.id === id);
    if (connector && connector.type === "AUTH" && chainId) {
      await connector.provider.connect({
        chainId,
        preferredAccountType: OptionsController.state.defaultAccountTypes.eip155
      });
    }
  }
  async getAccounts(params) {
    const connector = this.connectors.find((c) => c.id === params.id);
    const selectedProvider = connector == null ? void 0 : connector.provider;
    if (!selectedProvider || !connector) {
      throw new Error("Provider not found");
    }
    if (params.id === ConstantsUtil.CONNECTOR_ID.AUTH) {
      const provider = connector["provider"];
      const { address, accounts: accounts2 } = await provider.connect();
      return Promise.resolve({
        accounts: (accounts2 || [{ address, type: "eoa" }]).map((account) => CoreHelperUtil.createAccount("eip155", account.address, account.type))
      });
    }
    const accounts = await selectedProvider.request({
      method: "eth_requestAccounts"
    });
    return {
      accounts: accounts.map((account) => CoreHelperUtil.createAccount("eip155", account, "eoa"))
    };
  }
  async disconnect(params) {
    if (!params.provider || !params.providerType) {
      throw new Error("Provider or providerType not provided");
    }
    switch (params.providerType) {
      case "WALLET_CONNECT":
        if (params.provider.session) {
          ;
          params.provider.disconnect();
        }
        break;
      case "AUTH":
        await params.provider.disconnect();
        break;
      case "ANNOUNCED":
      case "EXTERNAL":
        await this.revokeProviderPermissions(params.provider);
        break;
      default:
        throw new Error("Unsupported provider type");
    }
  }
  async getBalance(params) {
    var _a;
    const address = params.address;
    const caipNetwork = (_a = this.caipNetworks) == null ? void 0 : _a.find((network) => network.id === params.chainId);
    if (!address) {
      return Promise.resolve({ balance: "0.00", symbol: "ETH" });
    }
    if (caipNetwork && caipNetwork.chainNamespace === "eip155") {
      const caipAddress = `${caipNetwork.caipNetworkId}:${address}`;
      const cachedPromise = this.balancePromises[caipAddress];
      if (cachedPromise) {
        return cachedPromise;
      }
      const cachedBalance = StorageUtil.getNativeBalanceCacheForCaipAddress(caipAddress);
      if (cachedBalance) {
        return { balance: cachedBalance.balance, symbol: cachedBalance.symbol };
      }
      const jsonRpcProvider = new JsonRpcProvider(caipNetwork.rpcUrls.default.http[0], {
        chainId: caipNetwork.id,
        name: caipNetwork.name
      });
      if (jsonRpcProvider) {
        try {
          this.balancePromises[caipAddress] = new Promise(async (resolve) => {
            const balance = await jsonRpcProvider.getBalance(address);
            const formattedBalance = formatEther(balance);
            StorageUtil.updateNativeBalanceCache({
              caipAddress,
              balance: formattedBalance,
              symbol: caipNetwork.nativeCurrency.symbol,
              timestamp: Date.now()
            });
            resolve({ balance: formattedBalance, symbol: caipNetwork.nativeCurrency.symbol });
          }).finally(() => {
            delete this.balancePromises[caipAddress];
          });
          return this.balancePromises[caipAddress] || { balance: "0.00", symbol: "ETH" };
        } catch (error) {
          return { balance: "0.00", symbol: "ETH" };
        }
      }
    }
    return { balance: "0.00", symbol: "ETH" };
  }
  async getProfile(params) {
    if (params.chainId === 1) {
      const ensProvider = new InfuraProvider("mainnet");
      const name = await ensProvider.lookupAddress(params.address);
      const avatar = await ensProvider.getAvatar(params.address);
      return { profileName: name || void 0, profileImage: avatar || void 0 };
    }
    return { profileName: void 0, profileImage: void 0 };
  }
  listenProviderEvents(provider) {
    const disconnect = () => {
      this.removeProviderListeners(provider);
      this.emit("disconnect");
    };
    const accountsChangedHandler = (accounts) => {
      if (accounts.length > 0) {
        this.emit("accountChanged", {
          address: accounts[0]
        });
      } else {
        disconnect();
      }
    };
    const chainChangedHandler = (chainId) => {
      const chainIdNumber = typeof chainId === "string" ? EthersHelpersUtil.hexStringToNumber(chainId) : Number(chainId);
      this.emit("switchNetwork", { chainId: chainIdNumber });
    };
    provider.on("disconnect", disconnect);
    provider.on("accountsChanged", accountsChangedHandler);
    provider.on("chainChanged", chainChangedHandler);
    this.providerHandlers = {
      disconnect,
      accountsChanged: accountsChangedHandler,
      chainChanged: chainChangedHandler
    };
  }
  removeProviderListeners(provider) {
    if (this.providerHandlers) {
      provider.removeListener("disconnect", this.providerHandlers.disconnect);
      provider.removeListener("accountsChanged", this.providerHandlers.accountsChanged);
      provider.removeListener("chainChanged", this.providerHandlers.chainChanged);
      this.providerHandlers = null;
    }
  }
  async switchNetwork(params) {
    var _a, _b;
    const { caipNetwork, provider, providerType } = params;
    if (providerType === "AUTH") {
      await super.switchNetwork(params);
      return;
    }
    try {
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: EthersHelpersUtil.numberToHexString(caipNetwork.id) }]
      });
    } catch (switchError) {
      if (switchError.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_INVALID_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_CODE_DEFAULT || ((_b = (_a = switchError == null ? void 0 : switchError.data) == null ? void 0 : _a.originalError) == null ? void 0 : _b.code) === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
        await EthersHelpersUtil.addEthereumChain(provider, caipNetwork);
      } else if (providerType === "ANNOUNCED" || providerType === "EXTERNAL" || providerType === "INJECTED") {
        throw new Error("Chain is not supported");
      }
    }
  }
  getWalletConnectProvider() {
    var _a;
    return (_a = this.connectors.find((c) => c.type === "WALLET_CONNECT")) == null ? void 0 : _a.provider;
  }
  async revokeProviderPermissions(provider) {
    try {
      const permissions = await provider.request({
        method: "wallet_getPermissions"
      });
      const ethAccountsPermission = permissions.find((permission) => permission.parentCapability === "eth_accounts");
      if (ethAccountsPermission) {
        await provider.request({
          method: "wallet_revokePermissions",
          params: [{ eth_accounts: {} }]
        });
      }
    } catch (error) {
      console.info("Could not revoke permissions from wallet. Disconnecting...", error);
    }
  }
  async getCapabilities(params) {
    var _a, _b;
    const provider = ProviderUtil.getProvider(ConstantsUtil.CHAIN.EVM);
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    const walletCapabilitiesString = (_b = (_a = provider.session) == null ? void 0 : _a.sessionProperties) == null ? void 0 : _b["capabilities"];
    if (walletCapabilitiesString) {
      const walletCapabilities = EthersMethods.parseWalletCapabilities(walletCapabilitiesString);
      const accountCapabilities = walletCapabilities[params];
      if (accountCapabilities) {
        return accountCapabilities;
      }
    }
    return await provider.request({ method: "wallet_getCapabilities", params: [params] });
  }
  async grantPermissions(params) {
    const provider = ProviderUtil.getProvider(ConstantsUtil.CHAIN.EVM);
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    return await provider.request({ method: "wallet_grantPermissions", params });
  }
  async revokePermissions(params) {
    const provider = ProviderUtil.getProvider(ConstantsUtil.CHAIN.EVM);
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    return await provider.request({ method: "wallet_revokePermissions", params: [params] });
  }
  async walletGetAssets(params) {
    const provider = ProviderUtil.getProvider(ConstantsUtil.CHAIN.EVM);
    if (!provider) {
      throw new Error("Provider is undefined");
    }
    return await provider.request({
      method: "wallet_getAssets",
      params: [params]
    });
  }
};
export {
  EthersAdapter,
  EthersHelpersUtil
};
//# sourceMappingURL=@reown_appkit-adapter-ethers.js.map
